---
layout: page
---


# Introduction

Eugene Wu

* PhD MIT, 2015
* Systems for Human Data Interaction
  * Database systems, data cleaning, explanation, visualization
* Other projects
  * WebTables
  * SASE
  * Neural Network debugging
* ewu@cs.columbia.edu

Agenda

* Logistics
* DB history
* Overview of database architecture (review)

Database Research

* Declarative API to manage data
* Enforces semantics
* Uses PL, optimization, systems, theory, ML to
  * Maintain data integrity (under programming/hardware failures)
  * Run queries correctly and quickly
  * Support growing application use cases

What makes the course great?

* 


Prereqs

* Should understand 4111 cold
* Ideally have taken 4112, which discusses DB implementation details
  * we will go over some important concepts since 4112 is not taught this semester
* See Ramakrishnan for basics



## Project Outline

Emphasis on related work

* Related work sounds boring but it is a landmark of many facets of life
  * Communication: they say I say
  * Selling a product:
  * Evaluating an idea
  * Assessing a paper's contribution
  * [The illustrated guide to the PhD](http://matt.might.net/articles/phd-school-in-pictures/)
  * Everything is _in relationship_ to what exists


Comparison with related work directly implies the appropriate hypotheses and metrics

* Along what metrics are you comparing against state of the art?
* Venn diagram of your work vs related work


Teams matched to a different team every two weeks.

* One team explains what they are doing to another team and vice versa
* Give feedback
* Submit feedback you received.  You submit review of the other team's project.

### Project Ideas




# Short DB History

* 60s:
  * CODASYL (Charles Bachman Turing #8)
  * IMS: hierarchical (think file system)

    suppliers -- parts

    * can't have parts without a supplier (can't have a null node in tree)
    * redundancy if many to many relationship (part A supplied by X and Y)
  * navigational pointer-chasing data manipulation language
    * aka for loops.  loops are fine (as qcompilation will show), but not for specification!
    * doesn't separate the data from the physical representation/execution
* 70
  * Codd's paper (Turing #18)
    * Set-based DMS
      * proved equivalent to relational calculus
    * Relationships are just sets
    * Data independence
    * Why do you want data independence?
      * When app changes slower than SW/HW environment
      * When else? Think cloud.  Menus abstract the food from the creation.  Instruction sets
* Mid 70s: the two teams
  * Ingres: Berkeley 74-77
    * Stonbraker (turing #32) and Wang 
    * influenced/begat ingres, britton-lee, sybase, ms sql server, PACE, tandem
  * SystemR: IBM almaden
    * big research team: 15 phds
    * begat: DB2, oracle, HP allbase, tandem
    * Jim Gray (turing #22)
  * Proved that the theory was practical.  Spawned RDBMS market and all software on top of it
  * We will read these papers
* 80s: The Market for "get DBs to work"
  * Oracle takes reads SystemR papers and goes to market
  * IBM releases several RDBMses, didn't want to cannibalize IMS initially. eventually releases DB2
  * Jim Gray and others join Tandem
  * Stonebraker makes Ingres
  * Britton/Lee from Ingres create Britton-Lee
  * Epstein leaves BL to create sybase (bought by SAP for 5B)
  * Wang creates PACE
  * Informix starts
  * Teradata started by caltech alums based on networking tech.  Moves into parallel DB space
  * SQL becomes the standard.  DB2 wins over IMS at IBM
  * Systems: db2, oracle, teradata, sybase, ingres
* late 80s: OODBMS
  * address impedance mismatch via nested model to colocate data aka JSON/XML
  * this was to basically avoid joins
  * breaking data independence
  * specialized language, vender lock-in, slows tech adoption
* 90s: More commercialization
  * Sybase --> SQLServer
  * MySQL
  * Postgres suppors SQL --> PostgreSQL
  * SQLite (late 90s)
* 2000s
  * warehouses
    * postgres -> (Netezza, Greenplum), MonetDB, Vertica, Paraccel -> redshift
    * Shared nothing, but limited scalability
    * Relational
    * OLAP, closed-source
* internet -> Scalibility -> NoSQL
  * BigTable, Dynamo, HBase, mongo, couchbase, cassandra
  * give up schema, relational data model, acid xacts, SQL
  * eventually consistent
  * Open source
* 2010s
  * NewSQL
    * Spanner, memsql, sap hana, volt, hyper, yugabyte, cockroach
    * ACID xacts, distributed, SQL
    * shared nothing partitions
  * HTAP
    * Memsql, hyper, snappy, peloton, sap hana
    * merge newsql and olap
  * cloud
    * designed for cloud: snowflake, fauna, redshift, aurora, spanner, azure
    * containerizes existing db: aws postgresql, etc
  * shared disk engines
    * Presto, snowflake, drill, redshift, azure cloud
    * Runs on Distributed storage (cloud env)
    * Separate storage and execution engine, scale independently
    * Lots of connectors to whatever file formats
    * Read into many execution nodes, high throughput to distributed disks
  * graph systems
    * Neo4j, tigergraph, dgraph, graphbase, giraph, etc
    * Innovation on graph api, NOT storage/execution 
    * Easily expressed under relational model
  * timeseries
    * timescale, influxdb, clickhouse, etc
    * heavily optimized for temporal data
    * timeseries has an ordering that is not well-expressed by relational model
  * Streaming
    * Continuous Qs: SASE, Telegraph, STREAM
    * Sliding windows: Aurora, Oracle CQL 
    * Scalability, best-effort: Twitter Storm
    * Out of order, state management, streaming SQL: Flink, Spark Streaming, Dataflow, kafka, materialized
* Today: scale and specialization.  Market for "get DBs to work at scale" and "for X"
  * New wave of distributed/scalable/forX database companies
* The big money arguably in apps built atop databases
  * Resource planning/Inventory tracking
  * CRM: Salesforce, IBM, 
  * Supply chains
  * HR/Direct Marketing/Call centers/automation/etc
  * Web companies: Facebook/etc
  * App generates SQL to access/query/modify the universe of data
  * DB makes easy to write these apps correctly



## Some Notes

We will primarily focus on query execution aspects, and have less focus on transactions/concurrency control and consistency.

We will contrast with general systems concepts when appropriate

The DBMS is one of the two major classes of software systems.  Other is OS.

* DB topdown design: start w/ semantics and declarative API.  Focus on correctness
* OS bottom up: elegant programming mechanisms (that compose, simple/minimal, etc)

# Resources

Reading papers

* [S Keshav](http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/data/07/paper-reading.pdf)
* [M Mitzenmacher](http://www.eecs.harvard.edu/~michaelm/postscripts/ReadPaper.pdf)
* [A Fedorova](http://www.cs.sfu.ca/~fedorova/Teaching/CMPT886/Spring2007/howtoreadpapers.html)

Research

* [You and Your Research](http://www.cs.virginia.edu/~robins/YouAndYourResearch.html): there are big problems and small problems
* [Research as Optimization](https://researchsetup.github.io/researchmodel)


