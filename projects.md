---
layout: page
title: W6113 Research Project
---

<style>
.cool {
  background-color: steelblue;
  color: white;
  text-weight: bold;
}
</style>

### Important Dates 

Percentages are of your total class grade.

* Prospectus    10-01   (10%)
* Paper Draft   10-29  (5%)
* Mock PC       11-10 to 11-12    (5%)
* Presentation  12-10  (10%)
* Report        12-14   (40%)



### Overview

The major portion of your grade is based on the research project. Students will organize into teams of 1-3 students and work on a research project.  It should take about 3-4 weeks to complete.  Some possible ideas are [described below](#suggestions).

Teams should consist of 1-3 people. In addition, if you have a project in mind, please indicate briefly (1--2 sentences) what you are thinking. We have included a list of possible projects at the end of this document although you are not required to choose from these.


Good class projects can vary dramatically in complexity, scope, and topic. The only requirement is that they be related to something we have studied in this class and that they contain some element of research -- e.g., that you do more than simply engineer a piece of software that someone else has described or architected. To help you determine if your idea is of reasonable scope, we will arrange to meet with each group several times throughout the semester.


<a name="prospectus" />
### Prospectus

Your research prospectus will contain an overview of the research problem, _your hypothesis_, first pass at related work, a description of how you plan to complete the project, and metrics to decide _if it worked_.   

Your prospectus should follow the example:

* [Click here for an example prospectus](./files/prospectus/prospectus.pdf)
* [Click here for the tex files](https://github.com/w6113/w6113.github.io/tree/master/files/prospectus)

**Submission**

1. Rename the filename of your prospectus to the following format, last names should be in **alphabetical order**. `prospectus_<UNI>_.._<UNIn>.pdf`
2. [**Click here to upload the file**](#)


<a name="midpoint"></a>
### Mock PC Meeting and Paper Draft

We will spend two class sessions running a mock program committee (PC) meeting.  The timeline for this will be as follows:

* **TBA  11:59PM EST** Submit a draft of your paper to CMT **[using the ACM proceedings LaTeX template](https://www.acm.org/publications/proceedings-template)**.   The draft should be a fleshed out version of your prospectus, with substantially more technical details and a sketch of your experiments.
* **TBA** You will be assigned 3-4 papers to review, and serve as the "lead" for one.  The review format will be the same as the reviews throughout the semester.
* **TBA 11:59PM EST** You will submit your reviews to CMT.   Read the other reviews for your assigned papers over the weekend.  
* **TBA** We will discuss each paper based on the reviews (authors will step out of the room).  Each reviewer will argue their view on the paper, and try to reach a consensus.  The lead is responsible for running the discussion.   The lead will also summarize the discussion/outcome into a meta review.  

#### The Paper Draft

Your paper should be no more than 10 pages, and include at least the following sections:

1. Introduction: motivate the problem, summarize related work, and declare your crisp hypothesis (or hypotheses).  This should be fully present.
2. Related Work: describe the state of the art in the most relevant research areas to your project.  This should be fully present.
3. Technical Overview: outline the technical approach you are taking so that the reader has an intuition about the solution.  This should be fully present.
4. Technical Details: considerably more technical details of your project, and details on what has been implemented.  The details should be mostly complete, but may not be implemented yet.
5. Experiments: describe the experimental setup as we have gone over in class.  You may not have run experiments yet.  If you have, feel free to include them.

In short, I expect that you have a much clearer idea about the problem _and_ how it can be solved.  Most of the technical details and relevant work should be clear, but you may not have implemented it yet.

**Submission**

* [Paper submission website](#).  MAKE SURE YOU USE THE CORRECT TEMPLATE.


#### Paper Reviews

Paper reviews address the same points as the roles that we have been focusing on.  They are different in that you want to propose concrete points that are great, and points that can use improvement.  Beyond that, study suggestions on how to review, and NOT review, papers:

* [Review AntiPatterns (written for FSE 14 PC)](https://homes.cs.washington.edu/~mernst/advice/review-antipatterns-devanbu.txt)
* [Ethics of Peer Review](https://ori.hhs.gov/sites/default/files/prethics.pdf)
* [How NOT to review a paper](https://sigmodrecord.org/publications/sigmodRecord/0812/p100.open.cormode.pdf)
* [Conference Reviewing Considered Harmful](https://homes.cs.washington.edu/~tom/support/confreview.pdf): A view on how reviewing works in practice.


#### PC Meeting

Preparation

* Read the reviews for each paper, including papers you did not review
* Prepare to share your perspective on each paper.


For each paper, we will choose one or more of the reviewers as the "Shephard".  Their job is to:

* Lead the discussion during the PC meeting
* Work with the individual reviewers to ensure that the reviews are complete, positive, constructive, and reflect the discussion.
* Work with the authors during the rest of the semester to ensure that the final version of the paper meets the standards from the PC discussion.
* In short, the paper's success is tied to the Shephard's success.

PC Meeting Format

* We will discuss half the papers in each lecture.
* Authors of the discussed paper will leave the room.
* PC will discuss the paper, along the dimensions that your review roles have been focusing on, and agree on feedback to provide authors
* Shephard will write a summary review emphasizing the main points for the authors
* Each reviewer will update their own reviews based on the discussion.  This can involve removing points, adding new comments, clarifying points, etc
* Shephard works with reviewers to ensure reviews are constructive.  
* Reviews are released day after the PC meeting at the latest.

Paper Discussion Format

* Shephard leads the discussion.  
* Reviewers summarize their overall impressions, then broader discussion about the merits of the work
* All reviewers and PC members have equal standing
* Shephard keeps the discussion on track, and keeps time.

<a name="shepherd"/>
#### Shepherd Duties after PC Meeting

* Go over all reviews for shepherd'd paper and ensure they are positive, detailed, and constructive.
* Write summary review, and get sign off by reviewers.
  * Summary review should be written in Details box of your review, under a heading such as 
  
        -------- SUMMARY REVIEW --------

* Discuss with paper authors in person to clarify review suggestions.


<a name="reflection"/>
#### Post-PC Meeting Reflection

[Use this form to submit](https://forms.gle/wmqKEU1AW4bMs3G4A)

Reflect on your own reviewing

1. For each paper you reviewed:
  * What are the top 3 or more ways in which your review is similar to the other reviewers?
  * What are the top 3 or more ways in which your review is different to the other reviews?
2. Overall, what are takeaways or lessons from this process that you can apply when you write reviews in the future?

Submit a reflection of your project

* How can you improve the motivation/introduction (if applicable)?
* How can you improve the technical ideas (if applicable)?
* How can you improve the evaluation (if applicable)?
* How can you improve the writing and argumentation (if applicable)?
* How useful were the reviews?






<!--
#### Poster Session (TBA)

Your team will prepare and present a project poster at the end-of-course poster session.   This gives you an opportunity to present a short demo of your work and show what you have accomplished in the class!

**Submission**

* Simply attend and present at the poster session.

-->

### Report/Camera Ready

You will prepare a conference-style report on your project with **maximum length** of 12 pages (10 pt font or larger, one or two columns, 1 inch margins, single or double spaced -- more is not better.) Your report should expand upon your prospectus and introduce and motivate the problem your project addresses, describe related work in the area, discuss the elements of your solution, and present results that measure the behavior, performance, or functionality of your system (with comparisons to other related systems as appropriate.)

Because this report is the primary deliverable upon which you will be graded, **do not treat it as an afterthought**. Plan to leave at least a week to do the writing, and make sure your proofread and edit carefully!

**Submission**

* [CMT website](https://cmt3.research.microsoft.com/W61132019/) by 5/10 11:59PM EST

<!-- [**Click here to upload the file by 5/2 11:59PM EST**](https://www.dropbox.com/request/9zdikb92vHFFPYtaFF0e) -->





<a name="suggestions"></a>
## Project Suggestions

The following are examples of possible projects -- they are by no means a complete list and **you are free to select your own projects**.  In fact, a common source of ideas is to take your experience from another domain, and combine it with databases/data management.  Projects often come in several flavors:

0. Make DataBass better: extend DataBass in a significant way, and evaluate it against other systems.  For instance, support DSM/PAX, Apache Arrow, distributed execution, LLVM compilation, lineage, etc.  Code quality matters for this option.
1. Research project: model an unsolved problem, propose algorithmic solution, evaluate and report findings.
2. Win: pick an existing useful application and a well-recognized metric (latency, prediction, etc) and win against the state of the art.
3. Break and fix: implement a state of the art algorithm on real data, show that it doesn't actually work (results are poor, it's slow, etc), make it work.
4. Evaluate: there are many options out there, it's not clear which ones are actually best, and under what conditions.  Run a bake-off and evaluate.
5. Fill a gap:  think about something useful that _should_ be easily doable, but is painful or impossible with current state of the art.  Fill that gap.



khameleon

* serverless/lmfao --> scalable backend
* progressively encoded and computed data cubes

databass/pysmoke

* apps of lineage
  * visualize lineage by leveraging the charts and queries 
    used to generate the lineage
  * smoke hilda
* add WCO joins and explore vicktor's paper
* databass --> rust / js
* columnar
* incorporate something interesting fro the readings
  * why not summarization
* use databass to do incremental computation in an incremental fashion (dbtoaster)
  * bonus: incremntally maintain lineage indexes
* benchmark vega and diff dataflow, find benchmarks
* add an IR, define the IR
* adding different access methods and extend optimizer to recognize

evaluate ml in databases

smoke for pandas?

* hand instrument c code for some operators to show feasibility

* expand on diffparsing with query language, apply to non-sql programs

cross layer signals for ML in systems

* informative features come from
  * interface feoatures from a viz that generate queries that run on the index
  * ast/query plan features that are known before the query is executed
  * batches of data that are inserted into the index
* find a learned index, show that adding occassional informative features 
  improves the model accuracy
* show that adding a mixture of informative and uninformative features 
* show that it improves the actual index performance on serial workloads
* what happens on a mixture of concurrent workloads
* connect to logging infrastructure

combining a streaming system with realitysketch ideas

rain

IFC for concurrency control



<!--

Potential ideas

* Apache Arrow is the defacto standard for moving data around.  Build an in-browser fast execution engine for apache arrow using asm and typed arrays.  You can assume that only foreign key joins are used (cardinality will not explode).
* query compiler to rust
* RL across execution layers 
* Some RL + data structure business


* Visualizations and clients currently need to poll from materialized
  * the system supports creating streaming sinks
  * extend vega lite to rewrite subsets of the spec into
    materialized views that can stream changes directly to the client.

use lineage in interesting ways

* not "show inputs", not "whynot"
* actually use it -- implement smoke hilda


-->
